import { exec } from 'node:child_process';
import { existsSync } from 'node:fs';
import { resolve } from 'node:path';
import { promisify } from 'node:util';
import type { ToolDefinition } from '../core/toolRuntime.js';

const execAsync = promisify(exec);

const SAFE_HOST_PATTERN = /^[a-zA-Z0-9._:-]+$/;
const SAFE_PORT_PATTERN = /^[0-9,\- ]+$/;
const SAFE_URL_PATTERN = /^[a-zA-Z0-9._~:/?#\[\]@!$&'()*+,;=%-]+$/;

export function createPentestTools(workingDir: string): ToolDefinition[] {
  return [
    {
      name: 'pentest_network_scan',
      description:
        'Run a fast recon scan against a target host. Prefers nmap (or rustscan if available) with templated profiles for defensive triage or red-team recon.',
      parameters: {
        type: 'object',
        properties: {
          target: {
            type: 'string',
            description: 'Hostname or IP to scan (single target).',
          },
          scan_profile: {
            type: 'string',
            enum: ['fast', 'full', 'udp', 'stealth'],
            description: 'Scan template to apply. Defaults to fast.',
          },
          ports: {
            type: 'string',
            description: 'Optional port list/ranges (e.g., "22,80,443" or "1-1024").',
          },
        },
        required: ['target'],
        additionalProperties: false,
      },
      handler: async (args) => {
        const target = requireSafeString(args['target'], 'target', SAFE_HOST_PATTERN);
        const profile =
          typeof args['scan_profile'] === 'string' && args['scan_profile'].trim()
            ? (args['scan_profile'] as string).trim()
            : 'fast';
        const portsRaw = typeof args['ports'] === 'string' ? args['ports'].trim() : '';
        if (portsRaw && !SAFE_PORT_PATTERN.test(portsRaw)) {
          return 'Invalid ports value. Use comma-separated integers or ranges (e.g., 1-1024,443,8443).';
        }

        const scanner = (await findBinary(['nmap'])) ?? (await findBinary(['rustscan']));
        if (!scanner) {
          return 'Install nmap or rustscan to run network scans.';
        }

        const command =
          scanner === 'nmap'
            ? buildNmapCommand(target, profile as string, portsRaw)
            : buildRustscanFallback(target, profile as string, portsRaw);

        return await runCommand(command, workingDir, 120_000);
      },
    },
    {
      name: 'pentest_web_scan',
      description:
        'Probe a web target using nuclei (preferred) or nikto/whatweb when available for quick vuln fingerprinting.',
      parameters: {
        type: 'object',
        properties: {
          url: {
            type: 'string',
            description: 'URL to scan (include scheme).',
          },
          severity: {
            type: 'string',
            description: 'Comma-separated severity list for nuclei (e.g., low,medium,high,critical).',
          },
        },
        required: ['url'],
        additionalProperties: false,
      },
      handler: async (args) => {
        const url = requireSafeString(args['url'], 'url', SAFE_URL_PATTERN);
        const severity =
          typeof args['severity'] === 'string' && args['severity'].trim()
            ? args['severity'].trim()
            : 'medium,high,critical';

        const scanner =
          (await findBinary(['nuclei'])) ?? (await findBinary(['nikto'])) ?? (await findBinary(['whatweb']));
        if (!scanner) {
          return 'Install nuclei, nikto, or whatweb to run a web scan.';
        }

        const command =
          scanner === 'nuclei'
            ? `nuclei -u ${url} -severity ${severity} -c 50 -silent`
            : scanner === 'nikto'
              ? `nikto -host ${url} -ask no`
              : `whatweb --color=never --log-verbose=- ${url}`;

        return await runCommand(command, workingDir, 120_000);
      },
    },
    {
      name: 'pentest_dir_enum',
      description:
        'Enumerate web directories/files using ffuf (preferred) or gobuster. Useful for both attack surface discovery and hardening checks.',
      parameters: {
        type: 'object',
        properties: {
          url: {
            type: 'string',
            description: 'Base URL to enumerate (use FUZZ marker for ffuf if you want custom placement).',
          },
          wordlist: {
            type: 'string',
            description: 'Path to a wordlist file on disk.',
          },
          threads: {
            type: 'number',
            description: 'Concurrent request threads (default 20).',
          },
        },
        required: ['url', 'wordlist'],
        additionalProperties: false,
      },
      handler: async (args) => {
        const url = requireSafeString(args['url'], 'url', SAFE_URL_PATTERN);
        const wordlist = resolve(workingDir, String(args['wordlist'] ?? '').trim());
        if (!existsSync(wordlist)) {
          return `Wordlist not found at ${wordlist}`;
        }
        const threads =
          typeof args['threads'] === 'number' && Number.isFinite(args['threads']) && args['threads'] > 0
            ? Math.min(Math.floor(args['threads']), 200)
            : 20;

        const scanner = (await findBinary(['ffuf'])) ?? (await findBinary(['gobuster']));
        if (!scanner) {
          return 'Install ffuf or gobuster to enumerate directories.';
        }

        const fuzzUrl = url.includes('FUZZ') ? url : `${url.replace(/\/$/, '')}/FUZZ`;
        const command =
          scanner === 'ffuf'
            ? `ffuf -u ${fuzzUrl} -w ${wordlist} -t ${threads} -mc 200,204,301,302,307,401,403 -r`
            : `gobuster dir -u ${url} -w ${wordlist} -t ${threads} -q -e`;

        return await runCommand(command, workingDir, 90_000);
      },
    },
    {
      name: 'pentest_host_baseline',
      description:
        'Collect a quick defensive baseline (whoami, kernel, listening sockets, recent logins, top processes) without external tools.',
      parameters: {
        type: 'object',
        properties: {},
        additionalProperties: false,
      },
      handler: async () => {
        const sections: string[] = [];

        sections.push(await labelledRun('Identity', 'whoami', workingDir));
        sections.push(await labelledRun('Kernel', 'uname -a', workingDir));
        sections.push(await labelledRun('Uptime', 'uptime', workingDir));
        sections.push(await labelledRun('Top processes', 'ps aux | head -n 20', workingDir));

        const socketCommand = (await findBinary(['ss']))
          ? 'ss -tulnp | head -n 20'
          : (await findBinary(['netstat']))
            ? 'netstat -tuln | head -n 20'
            : null;
        if (socketCommand) {
          sections.push(await labelledRun('Listening sockets', socketCommand, workingDir));
        } else {
          sections.push('--- Listening sockets ---\nss/netstat not available on this host.');
        }

        const loginsCommand = (await findBinary(['last'])) ? 'last -n 5' : null;
        if (loginsCommand) {
          sections.push(await labelledRun('Recent logins', loginsCommand, workingDir));
        }

        return sections.filter(Boolean).join('\n\n');
      },
    },
  ];
}

function requireSafeString(value: unknown, label: string, pattern: RegExp): string {
  const normalized = typeof value === 'string' ? value.trim() : '';
  if (!normalized) {
    throw new Error(`${label} is required.`);
  }
  if (!pattern.test(normalized)) {
    throw new Error(`Invalid ${label}: contains unsupported characters.`);
  }
  return normalized;
}

async function findBinary(candidates: string[]): Promise<string | null> {
  for (const name of candidates) {
    try {
      await execAsync(`command -v ${name}`);
      return name;
    } catch {
      continue;
    }
  }
  return null;
}

function buildNmapCommand(target: string, profile: string, ports: string): string {
  const portFlag = ports ? `-p ${ports}` : '';
  switch (profile) {
    case 'full':
      return `nmap -T4 -A -Pn ${portFlag} ${target}`.trim();
    case 'udp':
      return `nmap -sU -T4 --top-ports 50 -Pn ${portFlag} ${target}`.trim();
    case 'stealth':
      return `nmap -sS -T3 -Pn ${portFlag || '-F'} ${target}`.trim();
    case 'fast':
    default:
      return `nmap -T4 -F -Pn ${portFlag} -sV ${target}`.trim();
  }
}

function buildRustscanFallback(target: string, profile: string, ports: string): string {
  const range = ports || (profile === 'full' ? '1-65535' : '1-2000');
  return `rustscan -a ${target} -r ${range} -- -sV`;
}

async function runCommand(command: string, cwd: string, timeoutMs: number): Promise<string> {
  try {
    const { stdout, stderr } = await execAsync(command, {
      cwd,
      timeout: timeoutMs,
      maxBuffer: 10 * 1024 * 1024,
    });

    return [stdout?.trim() ? stdout.trim() : null, stderr?.trim() ? `stderr:\n${stderr.trim()}` : null]
      .filter(Boolean)
      .join('\n\n') || `Executed: ${command}`;
  } catch (error: any) {
    if (error.killed) {
      return `Command timed out after ${Math.round(timeoutMs / 1000)}s: ${command}`;
    }
    const stderr = error?.stderr ? String(error.stderr).trim() : null;
    return `Error running "${command}": ${error?.message ?? error}\n${stderr ? `stderr:\n${stderr}` : ''}`;
  }
}

async function labelledRun(label: string, command: string, cwd: string): Promise<string> {
  const output = await runCommand(command, cwd, 15_000);
  return `--- ${label} ---\n${output}`;
}
